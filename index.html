<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organizations in FMxAI</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Minimal SAT solver implementation for label placement
        // Uses DPLL algorithm (Davis–Putnam–Logemann–Loveland)
        class SimpleSAT {
            constructor() {
                this.clauses = [];
                this.numVars = 0;
            }

            newVar() {
                return ++this.numVars;
            }

            addClause(literals) {
                this.clauses.push(literals);
            }

            solve() {
                const assignment = new Array(this.numVars + 1).fill(undefined);
                return this.dpll(assignment, 0);
            }

            dpll(assignment, depth) {
                // Check if all clauses satisfied
                let allSatisfied = true;
                for (const clause of this.clauses) {
                    const clauseResult = this.evalClause(clause, assignment);
                    if (clauseResult === false) return null; // Conflict
                    if (clauseResult === undefined) allSatisfied = false;
                }
                if (allSatisfied) return assignment;

                // Choose next unassigned variable
                let nextVar = -1;
                for (let i = 1; i <= this.numVars; i++) {
                    if (assignment[i] === undefined) {
                        nextVar = i;
                        break;
                    }
                }
                if (nextVar === -1) return assignment;

                // Try true
                assignment[nextVar] = true;
                const result1 = this.dpll(assignment, depth + 1);
                if (result1) return result1;

                // Try false
                assignment[nextVar] = false;
                const result2 = this.dpll(assignment, depth + 1);
                if (result2) return result2;

                // Backtrack
                assignment[nextVar] = undefined;
                return null;
            }

            evalClause(clause, assignment) {
                let hasUndefined = false;
                for (const lit of clause) {
                    const varIdx = Math.abs(lit);
                    const val = assignment[varIdx];
                    if (val === undefined) {
                        hasUndefined = true;
                    } else {
                        const litVal = lit > 0 ? val : !val;
                        if (litVal) return true; // Clause satisfied
                    }
                }
                return hasUndefined ? undefined : false;
            }
        }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
            padding: 1rem;
            margin: 0;
        }
        #main-container {
            display: flex;
            gap: 1rem;
            height: calc(100vh - 2rem);
        }
        #left-panel {
            flex: 1;
            background: #1e293b;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #right-panel {
            width: 400px;
            background: #1e293b;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            overflow-y: auto;
        }
        #venn-container {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        h1 {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 1.5rem;
            font-weight: 600;
        }
        p {
            margin-bottom: 2rem;
            line-height: 1.6;
        }
        a {
            color: #fff;
            text-decoration: underline;
        }
        a:hover {
            color: #e2e8f0;
        }
        #venn {
            display: block;
            margin: 0 auto;
            border: 2px solid #475569;
            border-radius: 8px;
            background: #1e293b;
            cursor: grab;
            width: 100%;
            height: 100%;
        }
        #venn:active {
            cursor: grabbing;
        }
        .jobs-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        .jobs-table th {
            text-align: left;
            padding: 0.75rem;
            background: #334155;
            color: #f1f5f9;
            font-weight: 600;
            border-bottom: 2px solid #475569;
        }
        .jobs-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #334155;
        }
        .jobs-table tr:hover {
            background: #334155;
        }
        .jobs-table a {
            color: #60a5fa;
            text-decoration: none;
        }
        .jobs-table a:hover {
            text-decoration: underline;
        }
        .no-careers {
            color: #94a3b8;
            font-style: italic;
        }
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #f1f5f9;
        }
        @media (max-width: 1024px) {
            #main-container {
                flex-direction: column;
            }
            #right-panel {
                width: 100%;
                max-height: 400px;
            }
            #left-panel {
                min-height: 500px;
            }
        }
        .circle {
            fill-opacity: 0.15;
            stroke-width: 2;
            stroke-opacity: 0.6;
        }
        .label {
            font-size: 14px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
        }
        .org-link {
            cursor: pointer;
            transition: all 0.2s;
        }
        .org-link:hover circle {
            r: 7;
        }
        .org-link:hover text {
            font-weight: 600;
        }
        .org-circle {
            fill: #fff;
            stroke: #fff;
            stroke-width: 2;
        }
        .org-text {
            font-size: 12px;
            fill: #e2e8f0;
            text-anchor: middle;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="main-container">
        <div id="left-panel">
            <h1>Formal Methods x Artificial Intelligence</h1>
            <p style="margin-bottom: 1.5rem;">
                This website tracks the FMxAI research community, mapping the landscape of groups, resources and projects. The site is <a href="https://github.com/maxvonhippel/FMxAI">open source</a>. Contact: maxvh [at] hey [dot] com
            </p>
            <div id="venn-container">
                <svg id="venn"></svg>
            </div>
        </div>
        <div id="right-panel">
            <div class="section-title">Career Opportunities</div>
            <table class="jobs-table">
                <thead>
                    <tr>
                        <th>Organization</th>
                        <th>Careers Page</th>
                    </tr>
                </thead>
                <tbody id="jobs-tbody">
                    <!-- Will be populated by JavaScript -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const width = 1000; // Will be scaled by viewBox
        const height = 800; // Will be scaled by viewBox
        const svg = d3.select('#venn')
            .attr('width', '100%')
            .attr('height', '100%')
            .attr('style', 'max-width: 100%;');

        d3.json('data.json').then(data => {
            // Populate jobs table
            const jobsTbody = document.getElementById('jobs-tbody');
            data.organizations
                .sort((a, b) => a.name.localeCompare(b.name))
                .forEach(org => {
                    const row = document.createElement('tr');

                    const nameCell = document.createElement('td');
                    const nameLink = document.createElement('a');
                    nameLink.href = org.url;
                    nameLink.target = '_blank';
                    nameLink.textContent = org.name;
                    nameCell.appendChild(nameLink);

                    const careersCell = document.createElement('td');
                    if (org.careers) {
                        const careersLink = document.createElement('a');
                        careersLink.href = org.careers;
                        careersLink.target = '_blank';
                        careersLink.textContent = 'View Careers';
                        careersCell.appendChild(careersLink);
                    } else {
                        careersCell.className = 'no-careers';
                        careersCell.textContent = 'No careers page';
                    }

                    row.appendChild(nameCell);
                    row.appendChild(careersCell);
                    jobsTbody.appendChild(row);
                });

            // Create main group for all content (so zoom applies to everything)
            const mainGroup = svg.append('g');

            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 4])
                .on('zoom', (event) => {
                    mainGroup.attr('transform', event.transform);
                });

            svg.call(zoom);
            // Analyze category relationships from the data
            const categoryGraph = data.categories.map((cat, i) => ({
                index: i,
                name: cat.name,
                color: cat.color,
                // Find which other categories share organizations with this one
                connections: data.categories.map((otherCat, j) => {
                    if (i === j) return 0;
                    // Count orgs that are in BOTH categories
                    const sharedOrgs = data.organizations.filter(org =>
                        org.categories.includes(cat.name) && org.categories.includes(otherCat.name)
                    ).length;
                    return sharedOrgs;
                }),
                // Count total orgs in this category
                orgCount: data.organizations.filter(org => org.categories.includes(cat.name)).length
            }));

            console.log("Category relationship graph:");
            categoryGraph.forEach(cat => {
                const connections = cat.connections.map((count, j) =>
                    count > 0 ? `${data.categories[j].name}(${count})` : null
                ).filter(x => x).join(', ');
                console.log(`  ${cat.name}: ${cat.orgCount} orgs, shares with: ${connections || 'none'}`);
            });

            // Compute circle sizes based on org count
            const minRadius = 80;
            const maxRadius = 160;
            const maxOrgCount = Math.max(...categoryGraph.map(c => c.orgCount));
            categoryGraph.forEach(cat => {
                cat.r = minRadius + (cat.orgCount / maxOrgCount) * (maxRadius - minRadius);
            });

            // Layout circles using force-directed algorithm with constraints
            const circles = categoryGraph.map((cat, i) => ({
                ...cat,
                x: width/2 + (Math.random() - 0.5) * 200,
                y: height/2 + (Math.random() - 0.5) * 200,
                vx: 0,
                vy: 0
            }));

            // Force-directed layout for circle positioning
            console.log("Computing circle layout...");
            const iterations = 500;
            const dt = 0.1;

            for (let iter = 0; iter < iterations; iter++) {
                // Reset forces
                circles.forEach(c => { c.fx = 0; c.fy = 0; });

                // Apply forces between all pairs of circles
                for (let i = 0; i < circles.length; i++) {
                    for (let j = i + 1; j < circles.length; j++) {
                        const dx = circles[j].x - circles[i].x;
                        const dy = circles[j].y - circles[i].y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 0.1;
                        const nx = dx / dist;
                        const ny = dy / dist;

                        const sharedOrgs = circles[i].connections[j];

                        if (sharedOrgs > 0) {
                            // Should overlap - attract if too far, repel if too close
                            // Target distance: circles overlap but not concentric
                            const targetDist = (circles[i].r + circles[j].r) * 0.75; // 75% to create good overlap
                            const force = (dist - targetDist) * 0.01;
                            circles[i].fx += nx * force;
                            circles[i].fy += ny * force;
                            circles[j].fx -= nx * force;
                            circles[j].fy -= ny * force;
                        } else {
                            // Shouldn't overlap - repel if too close
                            const minSeparation = circles[i].r + circles[j].r + 80; // 80px buffer
                            if (dist < minSeparation) {
                                const force = (minSeparation - dist) * 0.02;
                                circles[i].fx -= nx * force;
                                circles[i].fy -= ny * force;
                                circles[j].fx += nx * force;
                                circles[j].fy += ny * force;
                            }
                        }
                    }
                }

                // Spring to center
                circles.forEach(c => {
                    c.fx += (width/2 - c.x) * 0.001;
                    c.fy += (height/2 - c.y) * 0.001;
                });

                // Update positions
                circles.forEach(c => {
                    c.vx = (c.vx + c.fx * dt) * 0.9; // Damping
                    c.vy = (c.vy + c.fy * dt) * 0.9;
                    c.x += c.vx;
                    c.y += c.vy;
                });
            }

            // Center the final layout
            const circleMinX = Math.min(...circles.map(c => c.x - c.r));
            const circleMaxX = Math.max(...circles.map(c => c.x + c.r));
            const circleMinY = Math.min(...circles.map(c => c.y - c.r));
            const circleMaxY = Math.max(...circles.map(c => c.y + c.r));
            const layoutWidth = circleMaxX - circleMinX;
            const layoutHeight = circleMaxY - circleMinY;
            const offsetX = (width - layoutWidth) / 2 - circleMinX;
            const offsetY = (height - layoutHeight) / 2 - circleMinY;

            circles.forEach(c => {
                c.x += offsetX;
                c.y += offsetY;
            });

            // Helper: check if point (px, py) is inside circle with configurable margin
            const isInCircle = (px, py, circle, margin = 5) => {
                const dx = px - circle.x;
                const dy = py - circle.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < circle.r - margin;
            };

            console.log("Circle positions:");
            circles.forEach((c, i) => {
                console.log(`${data.categories[i].name}: center(${c.x.toFixed(1)}, ${c.y.toFixed(1)}), radius=${c.r}`);
            });

            // Helper: verify point satisfies category constraints
            const satisfiesConstraints = (px, py, requiredCategories) => {
                for (let i = 0; i < circles.length; i++) {
                    const categoryName = data.categories[i].name;
                    const shouldBeIn = requiredCategories.includes(categoryName);
                    const isIn = isInCircle(px, py, circles[i]);
                    if (shouldBeIn && !isIn) return false;
                    if (!shouldBeIn && isIn) return false;
                }
                return true;
            };

            // Draw circles
            mainGroup.selectAll('.circle')
                .data(circles)
                .join('circle')
                .attr('class', 'circle')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', d => d.r)
                .attr('fill', d => d.color)
                .attr('stroke', d => d.color);

            // We'll position circle labels after SAT solving

            // Helper: check if two positions overlap (collision detection)
            const positionsOverlap = (p1, p2, minDist = 50) => {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                return Math.sqrt(dx * dx + dy * dy) < minDist;
            };

            // Generate candidate grid positions
            const gridStep = 18; // Balanced grid for good coverage without too many candidates
            const candidatePositions = [];
            for (let x = 80; x < width - 80; x += gridStep) {
                for (let y = 80; y < height - 80; y += gridStep) {
                    candidatePositions.push({ x, y });
                }
            }
            console.log(`Generated ${candidatePositions.length} candidate positions (${gridStep}px grid)`);

            // Helper: compute quality score for a position (higher = better)
            // Prefers positions:
            // 1. Well inside required circles (far from their edges)
            // 2. Well outside non-required circles (far from their edges)
            const scorePosition = (pos, requiredCategories) => {
                let minDistToEdge = Infinity;

                // Check distance to edges of all circles
                for (let i = 0; i < circles.length; i++) {
                    const categoryName = data.categories[i].name;
                    const shouldBeIn = requiredCategories.includes(categoryName);

                    const dx = pos.x - circles[i].x;
                    const dy = pos.y - circles[i].y;
                    const distToCenter = Math.sqrt(dx * dx + dy * dy);

                    if (shouldBeIn) {
                        // For required circles: reward being well inside (far from edge)
                        // Distance from center to edge minus distance to center = distance to edge from inside
                        const distToEdge = circles[i].r - distToCenter;
                        minDistToEdge = Math.min(minDistToEdge, distToEdge);
                    } else {
                        // For non-required circles: reward being well outside (far from edge)
                        // Distance to center minus radius = distance to edge from outside
                        const distToEdge = distToCenter - circles[i].r;
                        // If this is negative, we're inside a circle we shouldn't be in (bad!)
                        // If this is small positive, we're barely outside (also bad - looks ambiguous)
                        // We want this to be large positive
                        minDistToEdge = Math.min(minDistToEdge, distToEdge);
                    }
                }

                // The score is the minimum clearance from any edge
                // Higher score = better position (well-buffered from all relevant edges)
                return minDistToEdge;
            };

            // For each org, find valid candidate positions with proper margins
            const orgValidPositions = data.organizations.map(org => {
                const valid = candidatePositions.filter(pos => {
                    // Check if position satisfies all category constraints with proper margins
                    for (let i = 0; i < circles.length; i++) {
                        const categoryName = data.categories[i].name;
                        const shouldBeIn = org.categories.includes(categoryName);

                        if (shouldBeIn) {
                            // Must be well inside required circles (12px margin)
                            const isIn = isInCircle(pos.x, pos.y, circles[i], 12);
                            if (!isIn) return false;
                        } else {
                            // Must be well outside non-required circles (20px clearance)
                            // Negative margin means we extend the exclusion zone outward
                            const isIn = isInCircle(pos.x, pos.y, circles[i], -20);
                            if (isIn) return false; // Reject if too close to a non-required circle
                        }
                    }
                    return true;
                }).map(pos => ({
                    ...pos,
                    score: scorePosition(pos, org.categories)
                })).sort((a, b) => b.score - a.score); // Sort by score descending

                return valid;
            });

            console.log("Valid positions per org (sorted by quality):");
            orgValidPositions.forEach((validPos, i) => {
                const avgScore = validPos.length > 0
                    ? (validPos.reduce((sum, p) => sum + p.score, 0) / validPos.length).toFixed(1)
                    : 'N/A';
                console.log(`  ${data.organizations[i].name} (${data.organizations[i].categories.join(', ')}): ${validPos.length} positions (avg score: ${avgScore})`);
            });

            // Backtracking constraint satisfaction solver
            console.log("Using backtracking CSP solver for placement...");

            const minDist = 60; // Minimum distance between orgs (increased for more buffer)

            // Backtracking search with timeout and instrumentation
            let backtrackCalls = 0;
            const maxBacktrackCalls = 100000; // Prevent infinite loops
            const backtrackStart = Date.now();

            function backtrack(orgIdx, assignments) {
                backtrackCalls++;

                // Timeout/call limit check
                if (backtrackCalls > maxBacktrackCalls) {
                    console.warn(`Backtracking exceeded ${maxBacktrackCalls} calls, aborting`);
                    return null;
                }
                if (Date.now() - backtrackStart > 5000) {
                    console.warn(`Backtracking exceeded 5 second timeout, aborting`);
                    return null;
                }

                // Base case: all orgs assigned
                if (orgIdx === data.organizations.length) {
                    return assignments;
                }

                const validPos = orgValidPositions[orgIdx];
                if (validPos.length === 0) {
                    console.error(`No valid positions for ${data.organizations[orgIdx].name}`);
                    return null;
                }

                // Try positions in order (already sorted by quality score)
                for (const pos of validPos) {
                    // Check if this position conflicts with any already-assigned org
                    let hasConflict = false;
                    for (let i = 0; i < orgIdx; i++) {
                        if (positionsOverlap(pos, assignments[i], minDist)) {
                            hasConflict = true;
                            break;
                        }
                    }

                    if (!hasConflict) {
                        // Try this assignment
                        assignments[orgIdx] = pos;
                        const result = backtrack(orgIdx + 1, assignments);
                        if (result) {
                            return result;
                        }
                        // Backtrack
                        assignments[orgIdx] = null;
                    }
                }

                // No valid assignment found for this org
                return null;
            }

            const assignments = new Array(data.organizations.length).fill(null);
            const solution = backtrack(0, assignments);

            console.log(`Backtracking made ${backtrackCalls} calls in ${Date.now() - backtrackStart}ms`);

            if (solution) {
                console.log("CSP solution found for organizations!");
                data.organizations.forEach((org, idx) => {
                    org.x = solution[idx].x;
                    org.y = solution[idx].y;
                    console.log(`  ${org.name}: (${org.x}, ${org.y})`);
                });

                // Verify no overlaps
                let hasOverlap = false;
                for (let i = 0; i < data.organizations.length; i++) {
                    for (let j = i + 1; j < data.organizations.length; j++) {
                        if (positionsOverlap(data.organizations[i], data.organizations[j], minDist)) {
                            console.error(`ERROR: ${data.organizations[i].name} and ${data.organizations[j].name} overlap!`);
                            hasOverlap = true;
                        }
                    }
                }
                if (!hasOverlap) {
                    console.log("✓ CSP solution verified: no organization overlaps");
                }
            } else {
                console.error("CSP solver failed to find solution! Trying greedy with relaxed constraints...");
                const relaxedMinDist = 50; // Still maintain good spacing

                let greedySuccess = true;
                data.organizations.forEach((org, orgIdx) => {
                    const validPos = orgValidPositions[orgIdx];
                    if (validPos.length > 0) {
                        let placed = false;
                        // Try positions in order of quality score
                        for (const pos of validPos) {
                            let overlaps = false;
                            for (let i = 0; i < orgIdx; i++) {
                                if (data.organizations[i].x && positionsOverlap(pos, data.organizations[i], relaxedMinDist)) {
                                    overlaps = true;
                                    break;
                                }
                            }
                            if (!overlaps) {
                                org.x = pos.x;
                                org.y = pos.y;
                                placed = true;
                                console.log(`  ${org.name} (greedy): (${org.x}, ${org.y}) score=${pos.score.toFixed(1)}`);
                                break;
                            }
                        }
                        if (!placed) {
                            // Use best scoring position even if it causes overlap
                            org.x = validPos[0].x;
                            org.y = validPos[0].y;
                            greedySuccess = false;
                            console.warn(`  ${org.name} (FORCED - may overlap): (${org.x}, ${org.y}) score=${validPos[0].score.toFixed(1)}`);
                        }
                    } else {
                        org.x = width / 2;
                        org.y = height / 2;
                        greedySuccess = false;
                        console.error(`  ${org.name}: NO VALID POSITIONS - using center`);
                    }
                });

                // Verify greedy placement
                if (greedySuccess) {
                    console.log("✓ Greedy placement succeeded without forced overlaps");
                } else {
                    console.warn("⚠ Greedy placement had to force some positions - overlaps may exist");
                }

                // Report any overlaps
                for (let i = 0; i < data.organizations.length; i++) {
                    for (let j = i + 1; j < data.organizations.length; j++) {
                        const dist = Math.sqrt(
                            Math.pow(data.organizations[i].x - data.organizations[j].x, 2) +
                            Math.pow(data.organizations[i].y - data.organizations[j].y, 2)
                        );
                        if (dist < relaxedMinDist) {
                            console.error(`  OVERLAP: ${data.organizations[i].name} ↔ ${data.organizations[j].name} (${dist.toFixed(1)}px apart, min ${relaxedMinDist}px)`);
                        }
                    }
                }
            }

            // Final check: ensure all orgs have positions
            data.organizations.forEach((org, idx) => {
                if (!org.x || !org.y) {
                    console.error(`Org ${org.name} missing position, using fallback`);
                    const validPos = orgValidPositions[idx];
                    if (validPos && validPos.length > 0) {
                        org.x = validPos[0].x;
                        org.y = validPos[0].y;
                    } else {
                        // Last resort: center of screen
                        org.x = width / 2;
                        org.y = height / 2;
                    }
                }
            });

            // Verify all organizations are positioned
            console.log("Final positions:", data.organizations.map(o => `${o.name}: (${o.x}, ${o.y})`));

            // Now optimize circle label positions
            // Generate candidate positions for each circle label (24 directions for more options)
            const labelDistance = 50; // Distance from circle edge to ensure label clears the circle
            const numDirections = 24;
            const directions = [];
            for (let i = 0; i < numDirections; i++) {
                const angle = (i / numDirections) * 2 * Math.PI;
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                directions.push({
                    name: `${(i * 360 / numDirections).toFixed(0)}°`,
                    dx: dx,
                    dy: dy
                });
            }

            const labelCandidates = circles.map(circle =>
                directions.map(dir => ({
                    x: circle.x + (circle.r + labelDistance) * dir.dx,
                    y: circle.y + (circle.r + labelDistance) * dir.dy,
                    direction: dir.name
                }))
            );

            // Helper: estimate text bounding box for a label
            const estimateTextBounds = (text, x, y) => {
                const fontSize = 14;
                const charWidth = 9; // Approximate width per character at 14px (increased for safety)
                const textWidth = text.length * charWidth + 10; // Add extra padding
                const textHeight = fontSize * 1.4; // Add more vertical padding

                // text-anchor: middle means text is centered at x
                // y is the baseline, so text extends above it
                return {
                    left: x - textWidth / 2,
                    right: x + textWidth / 2,
                    top: y - textHeight,
                    bottom: y + 6 // Small space below baseline
                };
            };

            // Helper: check if a text bounding box overlaps with a circle
            const textBoxOverlapsCircle = (bounds, circle) => {
                // Find closest point on the rectangle to the circle center
                const closestX = Math.max(bounds.left, Math.min(circle.x, bounds.right));
                const closestY = Math.max(bounds.top, Math.min(circle.y, bounds.bottom));

                const dx = closestX - circle.x;
                const dy = closestY - circle.y;
                const distSq = dx * dx + dy * dy;

                // Check if closest point is inside the circle
                return distSq < circle.r * circle.r;
            };

            // Helper: check if label at position overlaps with any circle
            const labelOverlapsAnyCircle = (labelPos, labelText, ownCircleIdx) => {
                const bounds = estimateTextBounds(labelText, labelPos.x, labelPos.y);

                for (let i = 0; i < circles.length; i++) {
                    // Check overlap with ALL circles including its own
                    if (textBoxOverlapsCircle(bounds, circles[i])) {
                        return true;
                    }
                }
                return false;
            };

            // Helper: check if two text bounding boxes overlap
            const textBoundsOverlap = (bounds1, bounds2) => {
                // Add small padding to ensure visual separation
                const padding = 10;
                return !(
                    bounds1.right + padding < bounds2.left ||
                    bounds2.right + padding < bounds1.left ||
                    bounds1.bottom + padding < bounds2.top ||
                    bounds2.bottom + padding < bounds1.top
                );
            };

            // Helper: check if two labels overlap (using their actual text bounds)
            const labelsOverlap = (pos1, text1, pos2, text2) => {
                const bounds1 = estimateTextBounds(text1, pos1.x, pos1.y);
                const bounds2 = estimateTextBounds(text2, pos2.x, pos2.y);
                return textBoundsOverlap(bounds1, bounds2);
            };

            // Filter valid label positions (must not overlap with ANY circle, including own)
            const validLabelPositions = labelCandidates.map((candidates, circleIdx) =>
                candidates.filter(pos => !labelOverlapsAnyCircle(pos, circles[circleIdx].name, circleIdx))
            );

            console.log("Valid label positions (must not overlap with any circles):");
            validLabelPositions.forEach((v, i) => {
                console.log(`  ${circles[i].name}: ${v.length} candidate positions`);
                if (v.length === 0) {
                    console.warn(`    WARNING: No valid positions found! All positions overlap with circles.`);
                }
            });

            // Use SAT solver for label placement to guarantee no overlaps
            console.log("Using SAT solver for label placement...");

            const sat = new SimpleSAT();

            // Create variables: labelVars[circleIdx][posIdx] = variable number
            const labelVars = validLabelPositions.map(positions =>
                positions.map(() => sat.newVar())
            );

            // Constraint 1: Each circle must have exactly one label position
            circles.forEach((circle, circleIdx) => {
                const positions = validLabelPositions[circleIdx];
                if (positions.length === 0) {
                    console.warn(`No valid positions for ${circle.name} label`);
                    return;
                }

                // At least one position (OR of all variables for this circle)
                sat.addClause(labelVars[circleIdx]);

                // At most one position (for each pair, at least one must be false)
                for (let i = 0; i < positions.length; i++) {
                    for (let j = i + 1; j < positions.length; j++) {
                        sat.addClause([-labelVars[circleIdx][i], -labelVars[circleIdx][j]]);
                    }
                }
            });

            // Constraint 2: No two labels can overlap (using actual text bounds)
            for (let i = 0; i < circles.length; i++) {
                for (let j = i + 1; j < circles.length; j++) {
                    const positionsI = validLabelPositions[i];
                    const positionsJ = validLabelPositions[j];

                    for (let pi = 0; pi < positionsI.length; pi++) {
                        for (let pj = 0; pj < positionsJ.length; pj++) {
                            if (labelsOverlap(positionsI[pi], circles[i].name, positionsJ[pj], circles[j].name)) {
                                // If these positions overlap, they can't both be true
                                sat.addClause([-labelVars[i][pi], -labelVars[j][pj]]);
                            }
                        }
                    }
                }
            }

            console.log(`SAT problem: ${sat.numVars} variables, ${sat.clauses.length} clauses`);
            const satSolution = sat.solve();
            let labelSolution = null;

            if (satSolution) {
                console.log("SAT solution found for labels!");
                labelSolution = circles.map((circle, circleIdx) => {
                    const positions = validLabelPositions[circleIdx];
                    for (let posIdx = 0; posIdx < positions.length; posIdx++) {
                        const varNum = labelVars[circleIdx][posIdx];
                        if (satSolution[varNum] === true) {
                            return positions[posIdx];
                        }
                    }
                    return null;
                });
            } else {
                console.error("SAT solver found no solution for labels!");
            }

            if (labelSolution && labelSolution.every(pos => pos !== null)) {
                console.log("Applying SAT solution to labels:");
                circles.forEach((circle, idx) => {
                    circle.labelX = labelSolution[idx].x;
                    circle.labelY = labelSolution[idx].y;
                    const dir = labelSolution[idx].direction || 'unknown';
                    console.log(`  ${circle.name}: ${dir} at (${circle.labelX.toFixed(1)}, ${circle.labelY.toFixed(1)})`);
                });

                // Verify no overlaps (SAT should guarantee this)
                let hasOverlap = false;
                for (let i = 0; i < circles.length; i++) {
                    for (let j = i + 1; j < circles.length; j++) {
                        const pos1 = { x: circles[i].labelX, y: circles[i].labelY };
                        const pos2 = { x: circles[j].labelX, y: circles[j].labelY };
                        if (labelsOverlap(pos1, circles[i].name, pos2, circles[j].name)) {
                            console.error(`ERROR: Labels ${circles[i].name} and ${circles[j].name} overlap despite SAT solution!`);
                            const bounds1 = estimateTextBounds(circles[i].name, pos1.x, pos1.y);
                            const bounds2 = estimateTextBounds(circles[j].name, pos2.x, pos2.y);
                            console.error(`  ${circles[i].name} bounds:`, bounds1);
                            console.error(`  ${circles[j].name} bounds:`, bounds2);
                            hasOverlap = true;
                        }
                    }
                }
                if (!hasOverlap) {
                    console.log("✓ SAT solution verified: no label overlaps");
                }
            } else {
                console.error("SAT solver failed - using greedy fallback");

                // Greedy fallback with strict checking
                circles.forEach((circle, circleIdx) => {
                    const validPos = validLabelPositions[circleIdx];
                    if (validPos.length > 0) {
                        let placed = false;
                        for (const pos of validPos) {
                            let overlaps = false;
                            for (let i = 0; i < circleIdx; i++) {
                                if (circles[i].labelX) {
                                    const otherPos = { x: circles[i].labelX, y: circles[i].labelY };
                                    if (labelsOverlap(pos, circle.name, otherPos, circles[i].name)) {
                                        overlaps = true;
                                        break;
                                    }
                                }
                            }
                            if (!overlaps) {
                                circle.labelX = pos.x;
                                circle.labelY = pos.y;
                                placed = true;
                                console.log(`  ${circle.name} (greedy): ${pos.direction}`);
                                break;
                            }
                        }
                        if (!placed) {
                            circle.labelX = validPos[0].x;
                            circle.labelY = validPos[0].y;
                            console.warn(`  ${circle.name} (forced, may overlap)`);
                        }
                    } else {
                        circle.labelX = circle.x;
                        circle.labelY = circle.y - circle.r - 20;
                        console.warn(`  ${circle.name} (default position)`);
                    }
                });
            }

            // Draw circle labels with optimized positions
            mainGroup.selectAll('.label')
                .data(circles)
                .join('text')
                .attr('class', 'label')
                .attr('x', d => d.labelX || d.x)
                .attr('y', d => d.labelY || (d.y - d.r - 15))
                .attr('fill', d => d.color)
                .text(d => d.name);

            // Draw organizations
            const orgGroups = mainGroup.selectAll('.org-link')
                .data(data.organizations)
                .join('g')
                .attr('class', 'org-link')
                .on('click', (e, d) => window.open(d.url, '_blank'));

            orgGroups.append('circle')
                .attr('class', 'org-circle')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', 5);

            orgGroups.append('text')
                .attr('class', 'org-text')
                .attr('x', d => d.x)
                .attr('y', d => d.y + 20)
                .text(d => d.name);

            // Calculate bounding box of entire visualization
            const padding = 50;
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

            // Include circles
            circles.forEach(c => {
                minX = Math.min(minX, c.x - c.r);
                maxX = Math.max(maxX, c.x + c.r);
                minY = Math.min(minY, c.y - c.r);
                maxY = Math.max(maxY, c.y + c.r);
            });

            // Include circle labels (with estimated text width)
            circles.forEach(c => {
                if (c.labelX && c.labelY) {
                    const bounds = estimateTextBounds(c.name, c.labelX, c.labelY);
                    minX = Math.min(minX, bounds.left);
                    maxX = Math.max(maxX, bounds.right);
                    minY = Math.min(minY, bounds.top);
                    maxY = Math.max(maxY, bounds.bottom);
                }
            });

            // Include org dots and labels
            data.organizations.forEach(org => {
                if (org.x && org.y) {
                    const bounds = estimateTextBounds(org.name, org.x, org.y + 20);
                    minX = Math.min(minX, org.x - 10, bounds.left);
                    maxX = Math.max(maxX, org.x + 10, bounds.right);
                    minY = Math.min(minY, org.y - 10, bounds.top);
                    maxY = Math.max(maxY, org.y + 10, bounds.bottom);
                }
            });

            const viewBoxWidth = maxX - minX + 2 * padding;
            const viewBoxHeight = maxY - minY + 2 * padding;
            const viewBoxX = minX - padding;
            const viewBoxY = minY - padding;

            svg.attr('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            console.log(`ViewBox: ${viewBoxX.toFixed(0)}, ${viewBoxY.toFixed(0)}, ${viewBoxWidth.toFixed(0)} x ${viewBoxHeight.toFixed(0)}`);
        });
    </script>
</body>
</html>
